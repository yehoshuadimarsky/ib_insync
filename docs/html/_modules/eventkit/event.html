

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>eventkit.event &mdash; ib_insync 0.9.58 documentation</title>
  

  
  
  
  
    <link rel="canonical" href="https://ib_insync.readthedocs.io_modules/eventkit/event.html"/>
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> ib_insync
          

          
          </a>

          
            
            
              <div class="version">
                0.9
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../readme.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">API docs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks.html">Notebooks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../recipes.html">Code recipes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../code.html">Source code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../links.html">Links</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">ib_insync</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>eventkit.event</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for eventkit.event</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">types</span>
<span class="kn">import</span> <span class="nn">weakref</span>
<span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Awaitable</span><span class="p">,</span> <span class="n">AsyncIterable</span>

<span class="kn">from</span> <span class="nn">.util</span> <span class="k">import</span> <span class="n">NO_VALUE</span><span class="p">,</span> <span class="n">loop</span>


<span class="k">class</span> <span class="nc">Event</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Enable event passing between loosly coupled components.</span>
<span class="sd">    The event emits values to connected listeners and has</span>
<span class="sd">    a selection of operators to create general data flow pipelines.</span>

<span class="sd">    Args:</span>
<span class="sd">        name: Name to use for this event.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s1">&#39;error_event&#39;</span><span class="p">,</span> <span class="s1">&#39;done_event&#39;</span><span class="p">,</span> <span class="s1">&#39;_name&#39;</span><span class="p">,</span> <span class="s1">&#39;_value&#39;</span><span class="p">,</span>
        <span class="s1">&#39;_slots&#39;</span><span class="p">,</span> <span class="s1">&#39;_done&#39;</span><span class="p">,</span> <span class="s1">&#39;_source&#39;</span><span class="p">,</span> <span class="s1">&#39;__weakref__&#39;</span><span class="p">)</span>

    <span class="n">NO_VALUE</span> <span class="o">=</span> <span class="n">NO_VALUE</span>
    <span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">_with_error_done_events</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">error_event</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sub event that emits errors from this event as</span>
<span class="sd">        ``emit(source, exception)``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">done_event</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sub event that emits when this event is done as</span>
<span class="sd">        ``emit(source)``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">_with_error_done_events</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error_event</span> <span class="o">=</span> <span class="n">Event</span><span class="p">(</span><span class="s1">&#39;error&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">done_event</span> <span class="o">=</span> <span class="n">Event</span><span class="p">(</span><span class="s1">&#39;done&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_slots</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># list of [obj, weakref, func] sublists</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__qualname__</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_value</span> <span class="o">=</span> <span class="n">NO_VALUE</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_done</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_source</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This event&#39;s name.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>

    <span class="k">def</span> <span class="nf">done</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        ``True`` if event has ended with no more emits coming,</span>
<span class="sd">        ``False`` otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_done</span>

    <span class="k">def</span> <span class="nf">set_done</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set this event to be ended. The event should not emit anything</span>
<span class="sd">        after that.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_done</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_done</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">done_event</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This event&#39;s last emitted value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value</span>
        <span class="k">return</span> <span class="n">NO_VALUE</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="n">NO_VALUE</span> <span class="k">else</span> \
            <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">v</span> <span class="k">if</span> <span class="n">v</span> <span class="k">else</span> <span class="n">NO_VALUE</span>

    <span class="k">def</span> <span class="nf">connect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">listener</span><span class="p">,</span> <span class="n">error</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">done</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keep_ref</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Connect a listener to this event. If the listener is added multiple</span>
<span class="sd">        times then it is invoked just as many times on emit.</span>

<span class="sd">        The ``+=`` operator can be used as a synonym for this method::</span>

<span class="sd">            import eventkit as ev</span>

<span class="sd">            def f(a, b):</span>
<span class="sd">                print(a * b)</span>

<span class="sd">            def g(a, b):</span>
<span class="sd">                print(a / b)</span>

<span class="sd">            event = ev.Event()</span>
<span class="sd">            event += f</span>
<span class="sd">            event += g</span>
<span class="sd">            event.emit(10, 5)</span>

<span class="sd">        Args:</span>
<span class="sd">            listener: The callback to invoke on emit of this event.</span>
<span class="sd">                It gets the ``*args`` from an emit as arguments.</span>
<span class="sd">            error: The callback to invoke on error of this event.</span>
<span class="sd">                It gets (this event, exception) as two arguments.</span>
<span class="sd">            done: The callback to invoke on ending of this event.</span>
<span class="sd">                It gets this event as single argument.</span>
<span class="sd">            keep_ref:</span>
<span class="sd">                * ``True``: A strong reference to the callable is kept</span>
<span class="sd">                * ``False``: If the callable allows weak refs and it is</span>
<span class="sd">                  garbage collected, then it is automatically disconnected</span>
<span class="sd">                  from this event.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">obj</span><span class="p">,</span> <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_split</span><span class="p">(</span><span class="n">listener</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">keep_ref</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;__weakref__&#39;</span><span class="p">):</span>
            <span class="n">ref</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_onFinalize</span><span class="p">)</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ref</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">slot</span> <span class="o">=</span> <span class="p">[</span><span class="n">obj</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">func</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_slots</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">slot</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">done</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">done_event</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">done</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">error</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error_event</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">disconnect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">listener</span><span class="p">,</span> <span class="n">error</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">done</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Disconnect a listener from this event.</span>

<span class="sd">        The ``-=`` operator can be used as a synonym for this method.</span>

<span class="sd">        Args:</span>
<span class="sd">            listener: The callback to disconnect. The callback is removed at</span>
<span class="sd">                most once. It is valid if the callback is already</span>
<span class="sd">                not connected.</span>
<span class="sd">            error: The error callback to disconnect.</span>
<span class="sd">            done: The done callback to disconnect.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">obj</span><span class="p">,</span> <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_split</span><span class="p">(</span><span class="n">listener</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">slot</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slots</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">slot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="n">obj</span> <span class="ow">or</span> <span class="n">slot</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">slot</span><span class="p">[</span><span class="mi">1</span><span class="p">]()</span> <span class="ow">is</span> <span class="n">obj</span><span class="p">)</span> \
                    <span class="ow">and</span> <span class="n">slot</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">is</span> <span class="n">func</span><span class="p">:</span>
                <span class="n">slot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">slot</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">slot</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">break</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_slots</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slots</span> <span class="k">if</span> <span class="n">s</span> <span class="o">!=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]]</span>
        <span class="k">if</span> <span class="n">error</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error_event</span><span class="o">.</span><span class="n">disconnect</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">done</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">done_event</span><span class="o">.</span><span class="n">disconnect</span><span class="p">(</span><span class="n">done</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">disconnect_obj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Disconnect all listeners on the given object.</span>
<span class="sd">        (also the error and done listeners).</span>

<span class="sd">        Args:</span>
<span class="sd">            obj: The target object that is to be completely removed from</span>
<span class="sd">              this event.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">slot</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slots</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">slot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="n">obj</span> <span class="ow">or</span> <span class="n">slot</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">slot</span><span class="p">[</span><span class="mi">1</span><span class="p">]()</span> <span class="ow">is</span> <span class="n">obj</span><span class="p">:</span>
                <span class="n">slot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">slot</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">slot</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_slots</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slots</span> <span class="k">if</span> <span class="n">s</span> <span class="o">!=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">error_event</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error_event</span><span class="o">.</span><span class="n">disconnect_obj</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">done_event</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">done_event</span><span class="o">.</span><span class="n">disconnect_obj</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">emit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Emit a new value to all connected listeners.</span>

<span class="sd">        Args:</span>
<span class="sd">            args: Argument values to emit to listeners.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_value</span> <span class="o">=</span> <span class="n">args</span>
        <span class="k">for</span> <span class="n">obj</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">func</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slots</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ref</span><span class="p">:</span>
                    <span class="n">obj</span> <span class="o">=</span> <span class="n">ref</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">func</span><span class="p">:</span>
                        <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">func</span><span class="p">:</span>
                        <span class="n">func</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">obj</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">error</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">error_event</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">error_event</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">error</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">Event</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span>
                        <span class="n">f</span><span class="s1">&#39;Value </span><span class="si">{args}</span><span class="s1"> caused exception for event </span><span class="si">{self}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">emit_threadsafe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Threadsafe version of :meth:`emit` that doesn&#39;t invoke the</span>
<span class="sd">        listeners directly but via the event loop.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">loop</span><span class="o">.</span><span class="n">call_soon_threadsafe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">emit</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Disconnect all listeners.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">slot</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slots</span><span class="p">:</span>
            <span class="n">slot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">slot</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">slot</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_slots</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Start the asyncio event loop, run this event to completion and</span>
<span class="sd">        return all values as a list::</span>

<span class="sd">            import eventkit as ev</span>

<span class="sd">            ev.Timer(0.25, count=10).run()</span>
<span class="sd">            -&gt;</span>
<span class="sd">            [0.25, 0.5, 0.75, 1.0, 1.25, 1.5, 1.75, 2.0, 2.25, 2.5]</span>

<span class="sd">        .. note::</span>

<span class="sd">            When running inside a Jupyter notebook this will give an error</span>
<span class="sd">            that the asyncio event loop is already running. This can be</span>
<span class="sd">            remedied by applying</span>
<span class="sd">            `nest_asyncio &lt;https://github.com/erdewit/nest_asyncio&gt;`_</span>
<span class="sd">            or by using the top-level ``await`` statement of Jupyter::</span>

<span class="sd">                await event.list()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">list</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">pipe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">targets</span><span class="p">:</span> <span class="s2">&quot;Event&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Form several events into a pipe::</span>

<span class="sd">            import eventkit as ev</span>

<span class="sd">            e1 = ev.Sequence(&#39;abcde&#39;)</span>
<span class="sd">            e2 = ev.Enumerate().map(lambda i, c: (i, i + ord(c)))</span>
<span class="sd">            e3 = ev.Star().pluck(1).map(chr)</span>

<span class="sd">            e1.pipe(e2, e3)     # or: ev.Event.Pipe(e1, e2, e3)</span>
<span class="sd">            -&gt;</span>
<span class="sd">            [&#39;a&#39;, &#39;c&#39;, &#39;e&#39;, &#39;g&#39;, &#39;i&#39;]</span>

<span class="sd">        Args:</span>
<span class="sd">            targets: One or more Events that have no source yet,</span>
<span class="sd">                or ``Event`` constructors that needs no arguments.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">source</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">targets</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">Event</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="n">t</span><span class="o">.</span><span class="n">set_source</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
            <span class="n">source</span> <span class="o">=</span> <span class="n">t</span>
        <span class="k">return</span> <span class="n">source</span>

    <span class="k">def</span> <span class="nf">fork</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">targets</span><span class="p">:</span> <span class="s2">&quot;Event&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Fork&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fork this event into one or more target events.</span>
<span class="sd">        Square brackets can be used as a synonym::</span>

<span class="sd">            import eventkit as ev</span>

<span class="sd">            ev.Range(2, 5)[ev.Min, ev.Max, ev.Sum].zip()</span>
<span class="sd">            -&gt;</span>
<span class="sd">            [(2, 2, 2), (2, 3, 5), (2, 4, 9)]</span>

<span class="sd">        The events in the fork can be combined by one of the join</span>
<span class="sd">        methods of ``Fork``.</span>

<span class="sd">        Args:</span>
<span class="sd">            targets: One or more events that have no source yet,</span>
<span class="sd">                or ``Event`` constructors that need no arguments.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fork</span> <span class="o">=</span> <span class="n">Fork</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">targets</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">Event</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="n">t</span><span class="o">.</span><span class="n">set_source</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">fork</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fork</span>

    <span class="k">def</span> <span class="nf">set_source</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_source</span> <span class="o">=</span> <span class="n">source</span>

    <span class="k">def</span> <span class="nf">_onFinalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ref</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">slot</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slots</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">slot</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="n">ref</span><span class="p">:</span>
                <span class="n">slot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">slot</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">slot</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_slots</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slots</span> <span class="k">if</span> <span class="n">s</span> <span class="o">!=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_split</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Split given callable in (object, function) tuple.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">FunctionType</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="vm">__self__</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="vm">__func__</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">BuiltinMethodType</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="vm">__self__</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">type</span><span class="p">:</span>
                <span class="c1"># built-in method</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="vm">__self__</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># built-in function</span>
                <span class="k">return</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Invalid callable: </span><span class="si">{c}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">aiter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">skip_to_last</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">tuples</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an asynchronous iterator that yields the emitted values</span>
<span class="sd">        from this event::</span>

<span class="sd">            async def coro():</span>
<span class="sd">                async for args in event.aiter():</span>
<span class="sd">                    ...</span>

<span class="sd">        :meth:`__aiter__` is a synonym for :meth:`aiter` with</span>
<span class="sd">        default arguments,</span>

<span class="sd">        Args:</span>
<span class="sd">            skip_to_last:</span>
<span class="sd">                * ``True``: Backlogged source values are skipped over to</span>
<span class="sd">                  yield only the latest value. Can be used as a</span>
<span class="sd">                  slipper clutch between a source that produces too fast</span>
<span class="sd">                  and the handling that can&#39;t keep up.</span>
<span class="sd">                * ``False``: All events are yielded.</span>
<span class="sd">            tuples:</span>
<span class="sd">                * ``True``: Always yield arguments as a tuple.</span>
<span class="sd">                * ``False``: Unpack single argument tuples.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">on_event</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
            <span class="n">q</span><span class="o">.</span><span class="n">put_nowait</span><span class="p">((</span><span class="kc">None</span><span class="p">,</span> <span class="n">args</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">on_error</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">error</span><span class="p">):</span>
            <span class="n">q</span><span class="o">.</span><span class="n">put_nowait</span><span class="p">((</span><span class="s1">&#39;ERROR&#39;</span><span class="p">,</span> <span class="n">error</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">on_done</span><span class="p">(</span><span class="n">source</span><span class="p">):</span>
            <span class="n">q</span><span class="o">.</span><span class="n">put_nowait</span><span class="p">((</span><span class="s1">&#39;DONE&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">done</span><span class="p">():</span>
            <span class="k">return</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Queue</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">on_event</span><span class="p">,</span> <span class="n">on_error</span><span class="p">,</span> <span class="n">on_done</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">what</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="k">await</span> <span class="n">q</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">skip_to_last</span><span class="p">:</span>
                    <span class="k">while</span> <span class="n">q</span><span class="o">.</span><span class="n">qsize</span><span class="p">():</span>
                        <span class="n">what</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">get_nowait</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">what</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">args</span> <span class="k">if</span> <span class="n">tuples</span> <span class="k">else</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> \
                        <span class="k">else</span> <span class="n">args</span> <span class="k">if</span> <span class="n">args</span> <span class="k">else</span> <span class="n">NO_VALUE</span>
                <span class="k">elif</span> <span class="n">what</span> <span class="o">==</span> <span class="s1">&#39;ERROR&#39;</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">args</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">break</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">disconnect</span><span class="p">(</span><span class="n">on_event</span><span class="p">,</span> <span class="n">on_error</span><span class="p">,</span> <span class="n">on_done</span><span class="p">)</span>

    <span class="fm">__iadd__</span> <span class="o">=</span> <span class="n">connect</span>
    <span class="fm">__isub__</span> <span class="o">=</span> <span class="n">disconnect</span>
    <span class="fm">__call__</span> <span class="o">=</span> <span class="n">emit</span>
    <span class="fm">__or__</span> <span class="o">=</span> <span class="n">pipe</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">f</span><span class="s1">&#39;Event&lt;{self.name()}, </span><span class="si">{self._slots}</span><span class="s1">&gt;&#39;</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_slots</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fork_targets</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Fork&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">fork_targets</span><span class="p">,</span> <span class="s1">&#39;__iter__&#39;</span><span class="p">):</span>
            <span class="n">fork_targets</span> <span class="o">=</span> <span class="p">(</span><span class="n">fork_targets</span><span class="p">,)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fork</span><span class="p">(</span><span class="o">*</span><span class="n">fork_targets</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__await__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Asynchronously await the next emit of an event::</span>

<span class="sd">            async def coro():</span>
<span class="sd">                args = await event</span>
<span class="sd">                ...</span>

<span class="sd">        If the event does an empty ``emit()``, then the value</span>
<span class="sd">        of ``args`` is set to ``util.NO_VALUE``.</span>

<span class="sd">        :meth:`wait` and :meth:`__await__` are each other&#39;s inverse.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">on_event</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">fut</span><span class="o">.</span><span class="n">done</span><span class="p">():</span>
                <span class="n">fut</span><span class="o">.</span><span class="n">set_result</span><span class="p">(</span>
                    <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">args</span> <span class="k">if</span> <span class="n">args</span> <span class="k">else</span> <span class="n">NO_VALUE</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">on_error</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">error</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">fut</span><span class="o">.</span><span class="n">done</span><span class="p">():</span>
                <span class="n">fut</span><span class="o">.</span><span class="n">set_exception</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">on_future_done</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">disconnect</span><span class="p">(</span><span class="n">on_event</span><span class="p">,</span> <span class="n">on_error</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">done</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Event already done&#39;</span><span class="p">)</span>
        <span class="n">fut</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Future</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">on_event</span><span class="p">,</span> <span class="n">on_error</span><span class="p">)</span>
        <span class="n">fut</span><span class="o">.</span><span class="n">add_done_callback</span><span class="p">(</span><span class="n">on_future_done</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fut</span><span class="o">.</span><span class="fm">__await__</span><span class="p">()</span>

    <span class="fm">__aiter__</span> <span class="o">=</span> <span class="n">aiter</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Synonym for :meth:`aiter` with default arguments::</span>

<span class="sd">        async def coro():</span>
<span class="sd">            async for args in event:</span>
<span class="sd">                ...</span>

<span class="sd">    :meth:`aiterate` and :meth:`__aiter__` are each other&#39;s inverse.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        See if callable is already connected.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">obj</span><span class="p">,</span> <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_split</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span>
            <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="n">obj</span> <span class="ow">or</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]()</span> <span class="ow">is</span> <span class="n">obj</span><span class="p">)</span> <span class="ow">and</span> <span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">is</span> <span class="n">func</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slots</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Don&#39;t pickle slots.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">with_error_done_event</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error_event</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">done_event</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="n">with_error_done_event</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">init</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">event_names</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convenience function for initializing multiple events as members</span>
<span class="sd">        of the given object.</span>

<span class="sd">        Args:</span>
<span class="sd">            event_names: Names to use for the created events.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">event_names</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">Event</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>

    <span class="c1"># dot access to constructors</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">create</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an event from a async iterator, awaitable, or event</span>
<span class="sd">        constructor without arguments.</span>

<span class="sd">        Args:</span>
<span class="sd">            obj: The source object. If it&#39;s already an event then it</span>
<span class="sd">              is passed as-is.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Event</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">obj</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">):</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Event</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">obj</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;__aiter__&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Event</span><span class="o">.</span><span class="n">aiterate</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;__await__&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Event</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Invalid type: </span><span class="si">{obj}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">wait</span><span class="p">(</span><span class="n">future</span><span class="p">:</span> <span class="n">Awaitable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Wait&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new event that emits the value of the</span>
<span class="sd">        awaitable when it becomes available and then set this event done.</span>

<span class="sd">        :meth:`wait` and :meth:`__await__` are each other&#39;s inverse.</span>

<span class="sd">        Args:</span>
<span class="sd">            future: Future to wait on.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Wait</span><span class="p">(</span><span class="n">future</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">aiterate</span><span class="p">(</span><span class="n">ait</span><span class="p">:</span> <span class="n">AsyncIterable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Aiterate&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new event that emits the yielded values from the</span>
<span class="sd">        asynchronous iterator.</span>

<span class="sd">        The asynchronous iterator serves as a source for both the time</span>
<span class="sd">        and value of emits.</span>

<span class="sd">        :meth:`aiterate` and :meth:`__aiter__` are each other&#39;s inverse.</span>

<span class="sd">        Args:</span>
<span class="sd">            ait: The asynchronous source iterator. It must ``await``</span>
<span class="sd">                at least once; If necessary use::</span>

<span class="sd">                    await asyncio.sleep(0)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Aiterate</span><span class="p">(</span><span class="n">ait</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">sequence</span><span class="p">(</span>
            <span class="n">values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">interval</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">times</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Sequence&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new event that emits the given values.</span>
<span class="sd">        Supply at most one ``interval`` or ``times``.</span>

<span class="sd">        Args:</span>
<span class="sd">            value: The source values.</span>
<span class="sd">            interval: Time interval in seconds between values.</span>
<span class="sd">            times: Relative times for individual values, in seconds since</span>
<span class="sd">                start of event. The sequence should match ``values``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Sequence</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">interval</span><span class="p">,</span> <span class="n">times</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">repeat</span><span class="p">(</span>
            <span class="n">value</span><span class="o">=</span><span class="n">NO_VALUE</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">interval</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">times</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Repeat&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new event that repeats ``value`` a number of ``count`` times.</span>

<span class="sd">        Args:</span>
<span class="sd">            value: The value to emit.</span>
<span class="sd">            count: Number of times to emit.</span>
<span class="sd">            interval: Time interval in seconds between values.</span>
<span class="sd">            times: Relative times for individual values, in seconds since</span>
<span class="sd">                start of event. The sequence should match ``values``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Repeat</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">range</span><span class="p">(</span>
            <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">interval</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">times</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Range&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new event that emits the values from a range.</span>

<span class="sd">        Args:</span>
<span class="sd">            args: Same as for built-in ``range``.</span>
<span class="sd">            interval: Time interval in seconds between values.</span>
<span class="sd">            times: Relative times for individual values, in seconds since</span>
<span class="sd">                start of event. The sequence should match the range.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Range</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="n">interval</span><span class="p">,</span> <span class="n">times</span><span class="o">=</span><span class="n">times</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">timerange</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Timerange&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new event that emits the datetime value, at that datetime,</span>
<span class="sd">        from a range of datetimes.</span>

<span class="sd">        Args:</span>
<span class="sd">            start: Start time, can be specified as:</span>

<span class="sd">                * ``datetime.datetime``.</span>
<span class="sd">                * ``datetime.time``: Today is used as date.</span>
<span class="sd">                * ``int`` or ``float``: Number of seconds relative to now.</span>
<span class="sd">                  Values will be quantized to the given step.</span>
<span class="sd">            end: End time, can be specified as:</span>

<span class="sd">                * ``datetime.datetime``.</span>
<span class="sd">                * ``datetime.time``: Today is used as date.</span>
<span class="sd">                * ``None``: No end limit.</span>
<span class="sd">            step: Number of seconds, or ``datetime.timedelta``,</span>
<span class="sd">                to space between values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Timerange</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">timer</span><span class="p">(</span><span class="n">interval</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Timer&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new timer event that emits at regularly paced intervals</span>
<span class="sd">        the number of seconds since starting it.</span>

<span class="sd">        Args:</span>
<span class="sd">            interval: Time interval in seconds between emits.</span>
<span class="sd">            count: Number of times to emit, or ``None`` for no limit.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Timer</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">marble</span><span class="p">(</span>
            <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">interval</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">times</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Marble&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new event that emits the values from a Rx-type marble string.</span>

<span class="sd">        Args:</span>
<span class="sd">            s: The string with characters that are emitted.</span>
<span class="sd">            interval: Time interval in seconds between values.</span>
<span class="sd">            times: Relative times for individual values, in seconds since</span>
<span class="sd">                start of event. The sequence should match the marble string.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Marble</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">interval</span><span class="p">,</span> <span class="n">times</span><span class="p">)</span>

    <span class="c1"># dot access to operators</span>

    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predicate</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Filter&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For every source value, apply predicate and re-emit when True.</span>

<span class="sd">        Args:</span>
<span class="sd">            predicate: The function to test every source value with.</span>
<span class="sd">                The default is to test the general truthiness with ``bool()``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Filter</span><span class="p">(</span><span class="n">predicate</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">skip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Skip&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Drop the first ``count`` values from source and follow the source</span>
<span class="sd">        after that.</span>

<span class="sd">        Args:</span>
<span class="sd">            count: Number of source values to drop.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Skip</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">take</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Take&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Re-emit first ``count`` values from the source and then end.</span>

<span class="sd">        Args:</span>
<span class="sd">            count: Number of source values to re-emit.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Take</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">takewhile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predicate</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;TakeWhile&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Re-emit values from the source until the predicate becomes False</span>
<span class="sd">        and then end.</span>

<span class="sd">        Args:</span>
<span class="sd">            predicate: The function to test every source value with.</span>
<span class="sd">                The default is to test the general truthiness with ``bool()``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">TakeWhile</span><span class="p">(</span><span class="n">predicate</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">dropwhile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predicate</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="ow">not</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">-&gt;</span> <span class="s2">&quot;DropWhile&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Drop source values until the predicate becomes False and after that</span>
<span class="sd">        re-emit everything from the source.</span>

<span class="sd">        Args:</span>
<span class="sd">            predicate: The function to test every source value with.</span>
<span class="sd">                The default is to test the inverted general truthiness.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">DropWhile</span><span class="p">(</span><span class="n">predicate</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">takeuntil</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">notifier</span><span class="p">:</span> <span class="s2">&quot;Event&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;TakeUntil&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Re-emit values from the source until the ``notifier`` emits</span>
<span class="sd">        and then end. If the notifier ends without any emit then</span>
<span class="sd">        keep passing source values.</span>

<span class="sd">        Args:</span>
<span class="sd">            notifier: Event that signals to end this event.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">TakeUntil</span><span class="p">(</span><span class="n">notifier</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">constant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constant</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Constant&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        On emit of the source emit a constant value::</span>

<span class="sd">            emit(value) -&gt; emit(constant)</span>

<span class="sd">        Args:</span>
<span class="sd">            constant: The constant value to emit.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Constant</span><span class="p">(</span><span class="n">constant</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">iterate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">it</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Iterate&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        On emit of the source, emit the next value from an iterator::</span>

<span class="sd">            emit(a, b, ...) -&gt; emit(next(it))</span>

<span class="sd">        The time of events follows the source and the values follow</span>
<span class="sd">        the iterator.</span>

<span class="sd">        Args:</span>
<span class="sd">            it: The source iterator to use for generating values. When the</span>
<span class="sd">                iterator is exhausted the event is set to be done.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Iterate</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Count&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Count and emit the number of source emits::</span>

<span class="sd">            emit(a, b, ...) -&gt; emit(count)</span>

<span class="sd">        Args:</span>
<span class="sd">            start: Start count.</span>
<span class="sd">            step: Add count by this amount for every new source value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Count</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Enumerate&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a count to every source value::</span>

<span class="sd">            emit(a, b, ...) -&gt; emit(count, a, b, ...)</span>

<span class="sd">        Args:</span>
<span class="sd">            start: Start count.</span>
<span class="sd">            step: Increase by this amount for every new source value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Enumerate</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">timestamp</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Timestamp&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a timestamp (from time.time()) to every source value::</span>

<span class="sd">            emit(a, b, ...) -&gt; emit(timestamp, a, b, ...)</span>

<span class="sd">        The timestamp is the float number in seconds since the</span>
<span class="sd">        midnight Jan 1, 1970 epoch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Timestamp</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">partial</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">left_args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Partial&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pad source values with extra arguments on the left::</span>

<span class="sd">            emit(a, b, ...) -&gt; emit(*left_args, a, b, ...)</span>

<span class="sd">        Args:</span>
<span class="sd">            left_args: Arguments to inject.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Partial</span><span class="p">(</span><span class="o">*</span><span class="n">left_args</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">partial_right</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">right_args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;PartialRight&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pad source values with extra arguments on the right::</span>

<span class="sd">            emit(a, b, ...) -&gt; emit(a, b, ..., *right_args)</span>

<span class="sd">        Args:</span>
<span class="sd">            right_args: Arguments to inject.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">PartialRight</span><span class="p">(</span><span class="o">*</span><span class="n">right_args</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">star</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Star&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Unpack a source tuple into positional arguments, similar to the</span>
<span class="sd">        star operator::</span>

<span class="sd">            emit((a, b, ...)) -&gt; emit(a, b, ...)</span>

<span class="sd">        :meth:`star` and :meth:`pack` are each other&#39;s inverse.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Star</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pack</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Pack&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pack positional arguments into a tuple::</span>

<span class="sd">            emit(a, b, ...) -&gt; emit((a, b, ...))</span>

<span class="sd">        :meth:`star` and :meth:`pack` are each other&#39;s inverse.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Pack</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pluck</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">selections</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s2">&quot;Pluck&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract arguments or nested properties from the source values.</span>

<span class="sd">        Select which argument positions to keep::</span>

<span class="sd">            emit(a, b, c, d).pluck(1, 2) -&gt; emit(b, c)</span>

<span class="sd">        Re-order arguments::</span>

<span class="sd">            emit(a, b, c).pluck(2, 1, 0) -&gt; emit(c, b, a)</span>

<span class="sd">        To do an empty emit leave ``selections`` empty::</span>

<span class="sd">            emit(a, b).pluck() -&gt; emit()</span>

<span class="sd">        Select nested properties from positional arguments::</span>

<span class="sd">            emit(person, account).pluck(</span>
<span class="sd">                &#39;1.number&#39;, &#39;0.address.street&#39;) -&gt;</span>

<span class="sd">            emit(account.number, person.address.street)</span>

<span class="sd">        If no value can be extracted then ``NO_VALUE`` is emitted in its place.</span>

<span class="sd">        Args:</span>
<span class="sd">            selections: The values to extract.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Pluck</span><span class="p">(</span><span class="o">*</span><span class="n">selections</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">map</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ordered</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">task_limit</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Map&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply a sync or async function to source values using</span>
<span class="sd">        positional arguments::</span>

<span class="sd">            emit(a, b, ...) -&gt; emit(func(a, b, ...))</span>

<span class="sd">        or if ``func`` returns an awaitable then it will be awaited::</span>

<span class="sd">            emit(a, b, ...) -&gt; emit(await func(a, b, ...))</span>

<span class="sd">        In case of timeout or other failure, ``NO_VALUE`` is emitted.</span>

<span class="sd">        Args:</span>
<span class="sd">            func: The function or coroutine constructor to apply.</span>
<span class="sd">            timeout: Timeout in seconds since coroutine is started</span>
<span class="sd">            ordered:</span>
<span class="sd">                * ``True``: The order of emitted results preserves the</span>
<span class="sd">                  order of the source values.</span>
<span class="sd">                * ``False``: Results are in order of completion.</span>
<span class="sd">            task_limit: Max number of concurrent tasks, or None for no limit.</span>

<span class="sd">        ``timeout``, ``ordered`` and ``task_limit`` apply to</span>
<span class="sd">        async functions only.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Map</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">ordered</span><span class="p">,</span> <span class="n">task_limit</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">emap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constr</span><span class="p">,</span> <span class="n">joiner</span><span class="p">:</span> <span class="s2">&quot;AddableJoinOp&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Emap&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Higher-order event map that creates a new ``Event`` instance</span>
<span class="sd">        for every source value::</span>

<span class="sd">            emit(a, b, ...) -&gt; new Event constr(a, b, ...)</span>

<span class="sd">        Args:</span>
<span class="sd">            constr: Constructor function for creating a new event.</span>
<span class="sd">                Apart from returning  an ``Event``, the constructor may also</span>
<span class="sd">                return an awaitable or an asynchronous iterator, in which</span>
<span class="sd">                case an ``Event`` will be created.</span>
<span class="sd">            joiner: Join operator to combine the emits of nested events.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Emap</span><span class="p">(</span><span class="n">constr</span><span class="p">,</span> <span class="n">joiner</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">mergemap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Mergemap&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :meth:`emap` that uses :meth:`merge` to combine the nested events::</span>

<span class="sd">            marbles = [</span>
<span class="sd">                &#39;A   B    C    D&#39;,</span>
<span class="sd">                &#39;_1   2  3    4&#39;,</span>
<span class="sd">                &#39;__K   L     M   N&#39;]</span>

<span class="sd">            ev.Range(3).mergemap(lambda v: ev.Marble(marbles[v]))</span>
<span class="sd">            -&gt;</span>
<span class="sd">            [&#39;A&#39;, &#39;1&#39;, &#39;K&#39;, &#39;B&#39;, &#39;2&#39;, &#39;L&#39;, &#39;3&#39;, &#39;C&#39;, &#39;M&#39;, &#39;4&#39;, &#39;D&#39;, &#39;N&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Mergemap</span><span class="p">(</span><span class="n">constr</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">concatmap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Concatmap&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :meth:`emap` that uses :meth:`concat` to combine the nested events::</span>

<span class="sd">            marbles = [</span>
<span class="sd">                &#39;A    B    C    D&#39;,</span>
<span class="sd">                &#39;_       1    2    3    4&#39;,</span>
<span class="sd">                &#39;__                  K    L      M   N&#39;]</span>

<span class="sd">            ev.Range(3).concatmap(lambda v: ev.Marble(marbles[v]))</span>
<span class="sd">            -&gt;</span>
<span class="sd">            [&#39;A&#39;, &#39;B&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;K&#39;, &#39;L&#39;, &#39;M&#39;, &#39;N&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Concatmap</span><span class="p">(</span><span class="n">constr</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">chainmap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Chainmap&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :meth:`emap` that uses :meth:`chain` to combine the nested events::</span>

<span class="sd">            marbles = [</span>
<span class="sd">                &#39;A    B    C    D           &#39;,</span>
<span class="sd">                &#39;_       1    2    3    4&#39;,</span>
<span class="sd">                &#39;__                  K    L      M   N&#39;]</span>

<span class="sd">            ev.Range(3).chainmap(lambda v: ev.Marble(marbles[v]))</span>
<span class="sd">            -&gt;</span>
<span class="sd">            [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;K&#39;, &#39;L&#39;, &#39;M&#39;, &#39;N&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Chainmap</span><span class="p">(</span><span class="n">constr</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">switchmap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Switchmap&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :meth:`emap` that uses :meth:`switch` to combine the nested events::</span>

<span class="sd">            marbles = [</span>
<span class="sd">                &#39;A    B    C    D           &#39;,</span>
<span class="sd">                &#39;_                 K    L      M   N&#39;,</span>
<span class="sd">                &#39;__      1    2      3    4&#39;</span>
<span class="sd">            ]</span>
<span class="sd">            ev.Range(3).switchmap(lambda v: Event.marble(marbles[v]))</span>
<span class="sd">            -&gt;</span>
<span class="sd">            [&#39;A&#39;, &#39;B&#39;, &#39;1&#39;, &#39;2&#39;, &#39;K&#39;, &#39;L&#39;, &#39;M&#39;, &#39;N&#39;])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Switchmap</span><span class="p">(</span><span class="n">constr</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">reduce</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">initializer</span><span class="o">=</span><span class="n">NO_VALUE</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Reduce&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply a two-argument reduction function to the previous reduction</span>
<span class="sd">        result and the current value and emit the new reduction result.</span>

<span class="sd">        Args:</span>
<span class="sd">            func: Reduction function::</span>

<span class="sd">                emit(args) -&gt; emit(func(prev_args, args))</span>

<span class="sd">            initializer: First argument of first reduction::</span>

<span class="sd">                    first_result = func(initializer, first_value)</span>

<span class="sd">                If no initializer is given, then the first result is</span>
<span class="sd">                emitted on the second source emit.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Reduce</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">initializer</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">min</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Min&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Minimum value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Min</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">max</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Max&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Maximum value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Max</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Sum&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Total sum.</span>

<span class="sd">        Args:</span>
<span class="sd">            start: Value added to total sum.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Sum</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">product</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Product&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Total product.</span>

<span class="sd">        Args:</span>
<span class="sd">            start: Initial start value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Product</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Mean&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Total average.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Mean</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">any</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Any&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test if predicate holds for at least one source value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Any</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">all</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;All&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test if predicate holds for all source values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">All</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ema</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">weight</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Ema&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Exponential moving average.</span>

<span class="sd">        Args:</span>
<span class="sd">            n: Number of periods.</span>
<span class="sd">            weight: Weight of new value.</span>

<span class="sd">        Give either ``n`` or ``weight``.</span>
<span class="sd">        The relation is ``weight = 2 / (n + 1)``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Ema</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">previous</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Previous&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For every source value, emit the ``count``-th previous value::</span>

<span class="sd">            source:  -ab---c--d-e-</span>
<span class="sd">            output:  --a---b--c-d-</span>

<span class="sd">        Starts emitting on the ``count + 1``-th source emit.</span>

<span class="sd">        Args:</span>
<span class="sd">            count: Number of periods to go back.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Previous</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pairwise</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Pairwise&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Emit ``(previous_source_value, current_source_value)`` tuples.</span>
<span class="sd">        Starts emitting on the second source emit::</span>

<span class="sd">            source:  -a----b------c--------d-----</span>
<span class="sd">            output:  ------(a,b)--(b,c)----(c,d)-</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Pairwise</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">changes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Changes&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Emit only source values that have changed from the previous value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Changes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">unique</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Unique&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Emit only unique values, dropping values that have already</span>
<span class="sd">        been emitted.</span>

<span class="sd">        Args:</span>
<span class="sd">            key: `The callable `&#39;key(value)`` is used to group values.</span>
<span class="sd">                The default of ``None`` groups values by equality.</span>
<span class="sd">                The resulting group must be hashable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Unique</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">last</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Last&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wait until source has ended and re-emit its last value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Last</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">list</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;List&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Collect all source values and emit as list when the source ends.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">List</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">deque</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Deque&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Emit a ``deque`` with the last ``count`` values from the source</span>
<span class="sd">        (or less in the lead-in phase).</span>

<span class="sd">        Args:</span>
<span class="sd">            count: Number of last periods to use, or 0 to use all.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Deque</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Array&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Emit a numpy array with the last ``count`` values from the source</span>
<span class="sd">        (or less in the lead-in phase).</span>

<span class="sd">        Args:</span>
<span class="sd">            count: Number of last periods to use, or 0 to use all.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Array</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">chunk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Chunk&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Chunk values up in lists of equal size. The last chunk can be shorter.</span>

<span class="sd">        Args:</span>
<span class="sd">            size: Chunk size.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Chunk</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">chunkwith</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">timer</span><span class="p">:</span> <span class="s2">&quot;Event&quot;</span><span class="p">,</span> <span class="n">emit_empty</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ChunkWith&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Emit a chunked list of values when the timer emits.</span>

<span class="sd">        Args:</span>
<span class="sd">            timer: Event to use for timing the chunks.</span>
<span class="sd">            emit_empty: Emit empty list if no values present since last emit.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ChunkWith</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">emit_empty</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">chain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">sources</span><span class="p">:</span> <span class="s2">&quot;Event&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Chain&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Re-emit from a source until it ends, then move to the next source,</span>
<span class="sd">        Repeat until all sources have ended, ending the chain.</span>
<span class="sd">        Emits from pending sources are queued up::</span>

<span class="sd">            source 1:  -a----b---c|</span>
<span class="sd">            source 2:        --2-----3--4|</span>
<span class="sd">            source 3:  ------------x---------y--|</span>
<span class="sd">            output:    -a----b---c2--3--4x---y--|</span>


<span class="sd">        Args:</span>
<span class="sd">            sources: Source events.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Chain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">sources</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">sources</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Merge&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Re-emit everything from the source events::</span>

<span class="sd">            source 1:  -a----b-------------c------d-|</span>
<span class="sd">            source 2:     ------1-----2------3--4-|</span>
<span class="sd">            source 3:      --------x----y--|</span>
<span class="sd">            output:    -a----b--1--x--2-y--c-3--4-d-|</span>

<span class="sd">        Args:</span>
<span class="sd">            sources: Source events.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">sources</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">concat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">sources</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Concat&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Re-emit everything from one source until it ends and then move</span>
<span class="sd">        to the next source::</span>

<span class="sd">            source 1:  -a----b-----|</span>
<span class="sd">            source 2:    --1-----2-----3----4--|</span>
<span class="sd">            source 3:                 -----------x--y--|</span>
<span class="sd">            output:    -a----b---------3----4----x--y--|</span>

<span class="sd">        Args:</span>
<span class="sd">            sources: Source events.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Concat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">sources</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">switch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">sources</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Switch&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Re-emit everything from one source and move to another source as soon</span>
<span class="sd">        as that other source starts to emit::</span>

<span class="sd">            source 1:  -a----b---c-----d---|</span>
<span class="sd">            source 2:        -----------x---y-|</span>
<span class="sd">            source 3:  ---------1----2----3-----|</span>
<span class="sd">            output:    -a----b--1----2--x---y---|</span>

<span class="sd">        Args:</span>
<span class="sd">            sources: Source events.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Switch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">sources</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">zip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">sources</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Zip&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Zip sources together: The i-th emit has the i-th value from</span>
<span class="sd">        each source as positional arguments. Only emits when each source has</span>
<span class="sd">        emtted its i-th value and ends when any source ends::</span>

<span class="sd">            source 1:    -a----b------------------c------d---e--f---|</span>
<span class="sd">            source 2:    --------1-------2-------3---------4-----|</span>
<span class="sd">            output emit: --------(a,1)---(b,2)----(c,3)----(d,4)-|</span>


<span class="sd">        Args:</span>
<span class="sd">            sources: Source events.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Zip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">sources</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ziplatest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">sources</span><span class="p">,</span> <span class="n">partial</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Ziplatest&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Emit zipped values with the latest value from each of the</span>
<span class="sd">        source events. Emits every time when a source emits::</span>

<span class="sd">            source 1:   -a-------------------b-------c---|</span>
<span class="sd">            source 2:   ---------------1--------------------2------|</span>
<span class="sd">            output emit: (a,NoValue)---(a,1)-(b,1)---(c,1)--(c,2)--|</span>

<span class="sd">        Args:</span>
<span class="sd">            sources: Source events.</span>
<span class="sd">            partial:</span>
<span class="sd">                * True: Use ``NoValue`` for sources that have not emitted yet.</span>
<span class="sd">                * False: Wait until all sources have emitted.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Ziplatest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">sources</span><span class="p">,</span> <span class="n">partial</span><span class="o">=</span><span class="n">partial</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">delay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delay</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Delay&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Time-shift all source events by a delay::</span>

<span class="sd">            source:  -abc-d-e---f---|</span>
<span class="sd">            output:  ---abc-d-e---f---|</span>

<span class="sd">        This applies to the source errors and the source done event as well.</span>

<span class="sd">        Args:</span>
<span class="sd">            delay: Time delay of all events (in seconds).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Delay</span><span class="p">(</span><span class="n">delay</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">timeout</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Timeout&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        When the source doesn&#39;t emit for longer than the timeout period,</span>
<span class="sd">        do an empty emit and set this event as done.</span>

<span class="sd">        Args:</span>
<span class="sd">            timeout: Timeout value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Timeout</span><span class="p">(</span><span class="n">timeout</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">throttle</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">maximum</span><span class="p">,</span> <span class="n">interval</span><span class="p">,</span> <span class="n">cost_func</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Throttle&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Limit number of emits per time without dropping values.</span>
<span class="sd">        Values that come in too fast are queued and re-emitted as soon</span>
<span class="sd">        as allowed by the limits.</span>

<span class="sd">        A nested ``status_event`` emits ``True`` when throttling starts</span>
<span class="sd">        and ``False`` when throttling ends.</span>

<span class="sd">        The limit can be dynamically changed with ``set_limit``.</span>

<span class="sd">        Args:</span>
<span class="sd">            maximum: Maximum payload per interval.</span>
<span class="sd">            interval: Time interval (in seconds).</span>
<span class="sd">            cost_func: The sum of ``cost_func(value)`` for every</span>
<span class="sd">                source value inside the ``interval`` that is to remain</span>
<span class="sd">                under the ``maximum``. The default is to count every</span>
<span class="sd">                source value as 1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Throttle</span><span class="p">(</span><span class="n">maximum</span><span class="p">,</span> <span class="n">interval</span><span class="p">,</span> <span class="n">cost_func</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">debounce</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delay</span><span class="p">,</span> <span class="n">on_first</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Debounce&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Filter out values from the source that happen in rapid succession.</span>

<span class="sd">        Args:</span>
<span class="sd">            delay: Maximal time difference (in seconds) between</span>
<span class="sd">                successive values before debouncing kicks in.</span>
<span class="sd">            on_first:</span>
<span class="sd">                * True: First value is send immediately and following values</span>
<span class="sd">                  in the rapid succession are dropped::</span>

<span class="sd">                    source: -abcd----efg-</span>
<span class="sd">                    output: -a-------e---</span>

<span class="sd">                * False: Last value of a rapid succession is send after</span>
<span class="sd">                  the delay and the values before that are dropped::</span>

<span class="sd">                    source:  -abcd----efg--</span>
<span class="sd">                    output:   ----d------g-</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Debounce</span><span class="p">(</span><span class="n">delay</span><span class="p">,</span> <span class="n">on_first</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Copy&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a shallow copy of the source values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Deepcopy&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a deep copy of the source values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timer</span><span class="p">:</span> <span class="s2">&quot;Event&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Sample&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        At the times that the timer emits, sample the value from this</span>
<span class="sd">        event and emit the sample.</span>

<span class="sd">        Args:</span>
<span class="sd">            timer: Event used to time the samples.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Sample</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">errors</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Errors&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Emit errors from the source.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Errors</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">end_on_error</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;EndOnError&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        End on any error from the source.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">EndOnError</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>


<span class="kn">from</span> <span class="nn">.ops.op</span> <span class="k">import</span> <span class="n">Op</span>  <span class="c1"># noqa</span>
<span class="kn">from</span> <span class="nn">.ops.create</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">Wait</span><span class="p">,</span> <span class="n">Aiterate</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Repeat</span><span class="p">,</span> <span class="n">Range</span><span class="p">,</span> <span class="n">Timerange</span><span class="p">,</span> <span class="n">Timer</span><span class="p">,</span> <span class="n">Marble</span><span class="p">)</span>  <span class="c1"># noqa</span>
<span class="kn">from</span> <span class="nn">.ops.combine</span> <span class="k">import</span> <span class="p">(</span><span class="n">Fork</span><span class="p">,</span> <span class="n">AddableJoinOp</span><span class="p">,</span> <span class="n">Chain</span><span class="p">,</span> <span class="n">Merge</span><span class="p">,</span> <span class="n">Concat</span><span class="p">,</span> <span class="n">Switch</span><span class="p">,</span>
    <span class="n">Zip</span><span class="p">,</span> <span class="n">Ziplatest</span><span class="p">)</span>  <span class="c1"># noqa</span>
<span class="kn">from</span> <span class="nn">.ops.select</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">Filter</span><span class="p">,</span> <span class="n">Skip</span><span class="p">,</span> <span class="n">Take</span><span class="p">,</span> <span class="n">TakeWhile</span><span class="p">,</span> <span class="n">DropWhile</span><span class="p">,</span> <span class="n">TakeUntil</span><span class="p">,</span> <span class="n">Changes</span><span class="p">,</span>
    <span class="n">Unique</span><span class="p">,</span> <span class="n">Last</span><span class="p">)</span>  <span class="c1"># noqa</span>
<span class="kn">from</span> <span class="nn">.ops.transform</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">Constant</span><span class="p">,</span> <span class="n">Iterate</span><span class="p">,</span> <span class="n">Enumerate</span><span class="p">,</span> <span class="n">Timestamp</span><span class="p">,</span> <span class="n">Chunk</span><span class="p">,</span> <span class="n">ChunkWith</span><span class="p">,</span>
    <span class="n">Map</span><span class="p">,</span> <span class="n">Emap</span><span class="p">,</span> <span class="n">Mergemap</span><span class="p">,</span> <span class="n">Chainmap</span><span class="p">,</span> <span class="n">Concatmap</span><span class="p">,</span> <span class="n">Switchmap</span><span class="p">,</span>
    <span class="n">Partial</span><span class="p">,</span> <span class="n">PartialRight</span><span class="p">,</span> <span class="n">Star</span><span class="p">,</span> <span class="n">Pack</span><span class="p">,</span> <span class="n">Pluck</span><span class="p">,</span>
    <span class="n">Previous</span><span class="p">,</span> <span class="n">Copy</span><span class="p">,</span> <span class="n">Deepcopy</span><span class="p">)</span>  <span class="c1"># noqa</span>
<span class="kn">from</span> <span class="nn">.ops.array</span> <span class="k">import</span> <span class="p">(</span><span class="n">Array</span><span class="p">,</span> <span class="n">ArrayMin</span><span class="p">,</span> <span class="n">ArrayMax</span><span class="p">,</span> <span class="n">ArraySum</span><span class="p">,</span>  <span class="c1"># noqa</span>
    <span class="n">ArrayProd</span><span class="p">,</span> <span class="n">ArrayMean</span><span class="p">,</span> <span class="n">ArrayStd</span><span class="p">,</span> <span class="n">ArrayAny</span><span class="p">,</span> <span class="n">ArrayAll</span><span class="p">)</span> <span class="c1"># noqa</span>
<span class="kn">from</span> <span class="nn">.ops.aggregate</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">Count</span><span class="p">,</span> <span class="n">Reduce</span><span class="p">,</span> <span class="n">Min</span><span class="p">,</span> <span class="n">Max</span><span class="p">,</span> <span class="n">Sum</span><span class="p">,</span> <span class="n">Product</span><span class="p">,</span> <span class="n">Mean</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">All</span><span class="p">,</span>
    <span class="n">Ema</span><span class="p">,</span> <span class="n">Pairwise</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Deque</span><span class="p">)</span>  <span class="c1"># noqa</span>
<span class="kn">from</span> <span class="nn">.ops.timing</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">Delay</span><span class="p">,</span> <span class="n">Timeout</span><span class="p">,</span> <span class="n">Throttle</span><span class="p">,</span> <span class="n">Debounce</span><span class="p">,</span> <span class="n">Sample</span><span class="p">)</span>  <span class="c1"># noqa</span>
<span class="kn">from</span> <span class="nn">.ops.misc</span> <span class="k">import</span> <span class="n">Errors</span><span class="p">,</span> <span class="n">EndOnError</span>  <span class="c1"># noqa</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Ewald de Wit

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>